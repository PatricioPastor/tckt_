// schema.prisma (Extended with App Models)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Auth Models (Generated by Better Auth)
model account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  user      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model user {
  id            String    @id
  name          String
  email         String    @unique
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime

  username      String?   @unique
  dni           String?
  birthDate     DateTime?
  role          Role      @default(user)
  tickets       ticket[]  @relation("ticketsToUser_ownerId")
  transferredTickets ticket[] @relation("ticketsToUser_transferredFromId")
  participants  participant[]
  rrppAssignments rrppAssignment[]
  account       account[]
  session       session[]
  logs          log[]
  sentMessages  message[] @relation("messagesToUser_senderId")
  receivedMessages message[] @relation("messagesToUser_receiverId")
  payments      payment[]
}

model verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
}

// Enums for App
enum Role {
  superadmin
  head_producer
  rrpp
  qr_scanner
  user
}

enum EventStatus {
  draft
  published
  finished
}


enum TicketStatus {
  pending
  paid
  used
  transferred
}

enum PaymentStatus {
  pending
  approved
  rejected
  cancelled
  refunded
  in_process
}

model payment {
  id                Int            @id @default(autoincrement())
  userId            String
  eventId           Int
  status            PaymentStatus  @default(pending)
  amount            Decimal        @db.Decimal(12, 2)
  currency          String         @default("ARS")
  provider          String         @default("mercadopago")

  externalReference String         @unique   // ej: order_<userId>_<eventId>_<ts>
  mpPreferenceId    String?                    // ID de preferencia
  mpPaymentId       String?        @unique     // ID de pago (cuando exista)

  payerEmail        String?
  payerName         String?

  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  user   user   @relation(fields: [userId], references: [id], onDelete: Cascade)
  event  event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets ticket[]
}

// App Models
model event {
  id               Int           @id @default(autoincrement())
  name             String
  date             DateTime
  location         String
  description      String?
  bannerUrl        String?
  status           EventStatus   @default(draft)
  producerId       Int           @default(1) // Hardcode single
  capacityTotal    Int?
  isRsvpAllowed    Boolean       @default(true)
  eventGenre       String?
  createdAt        DateTime      @default(now())
  ticketTypes      ticketType[]
  eventArtists     eventArtist[]
  tickets          ticket[]
  participants     participant[]
  rrppAssignments  rrppAssignment[]
  payments         payment[]
}

model artist {
  id           Int           @id @default(autoincrement())
  name         String
  bio          String?
  imageUrl     String?
  socialLinks  Json?         // Array of strings
  eventArtists eventArtist[]
}

model eventArtist {
  eventId     Int
  artistId    Int
  order       Int?
  slotTime    String?
  isHeadliner Boolean       @default(false)
  artist      artist        @relation(fields: [artistId], references: [id], onDelete: Cascade)
  event       event         @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([eventId, artistId])
}

model ticketType {
  id              Int      @id @default(autoincrement())
  eventId         Int
  code            String   // identificador lógico único por evento (p.ej. "tier1", "door")
  label           String   // cómo lo ve el usuario (p.ej. "TIER 1", "EN PUERTA")
  price           Decimal  @db.Decimal(12, 2)
  stockMax        Int
  stockCurrent    Int
  userMaxPerType  Int      @default(5)
  scanExpiration  DateTime?
  event           event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  tickets         ticket[]

  @@unique([eventId, code])
}


model ticket {
  id                  Int           @id @default(autoincrement())
  eventId             Int
  ownerId             String
  typeId              Int
  paymentId           Int?          // Foreign key to payment
  qrCode              String       @unique 
  code                String?       @unique
  status              TicketStatus  @default(pending)
  transferredFromId   String?
  createdAt           DateTime      @default(now())
  event               event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  owner               user          @relation("ticketsToUser_ownerId", fields: [ownerId], references: [id], onDelete: Restrict)
  type                ticketType    @relation(fields: [typeId], references: [id], onDelete: Cascade)
  transferredFrom     user?         @relation("ticketsToUser_transferredFromId", fields: [transferredFromId], references: [id])
  payment             payment?      @relation(fields: [paymentId], references: [id], onDelete: SetNull)
}

model rrppAssignment {
  rrppUserId     String
  eventId        Int
  commissionRate Decimal       @default(0.10)
  freesGranted   Int           @default(0)
  rrppUser       user          @relation(fields: [rrppUserId], references: [id], onDelete: Cascade)
  event          event         @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([rrppUserId, eventId])
}

model participant {
  userId     String
  eventId    Int
  viaRsvp    Boolean       @default(false)
  qrCode     String?
  user       user          @relation(fields: [userId], references: [id], onDelete: Cascade)
  event      event         @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([userId, eventId])
}

model log {
  id        Int      @id @default(autoincrement())
  userId    String?
  action    String
  timestamp DateTime @default(now())
  details   Json?
  user      user?    @relation(fields: [userId], references: [id])
}

model message {
  id          Int      @id @default(autoincrement())
  senderId    String
  receiverId  String
  message     String
  timestamp   DateTime @default(now())
  readStatus  Boolean  @default(false)
  sender      user     @relation("messagesToUser_senderId", fields: [senderId], references: [id], onDelete: Cascade)
  receiver    user     @relation("messagesToUser_receiverId", fields: [receiverId], references: [id], onDelete: Cascade)
}