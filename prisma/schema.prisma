generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  user      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      user     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model user {
  id                 String           @id
  name               String
  email              String           @unique
  emailVerified      Boolean
  image              String?
  createdAt          DateTime
  updatedAt          DateTime
  username           String?          @unique
  dni                String?
  birthDate          DateTime?
  role               Role             @default(user)
  image_base64       String?
  account            account[]
  guestsCheckedIn    guestList[]
  guestsImported     guestList[]      @relation("guestListImporter")
  logs               log[]
  receivedMessages   message[]        @relation("messagesToUser_receiverId")
  sentMessages       message[]        @relation("messagesToUser_senderId")
  participants       participant[]
  payments           payment[]
  producer           producer?
  rrppAssignments    rrppAssignment[]
  session            session[]
  tickets            ticket[]         @relation("ticketsToUser_ownerId")
  transferredTickets ticket[]         @relation("ticketsToUser_transferredFromId")
}

model verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?
}

model payment {
  id                Int           @id @default(autoincrement())
  userId            String        @map("user_id")
  eventId           Int           @map("event_id")
  status            PaymentStatus @default(pending)
  amount            Decimal       @db.Decimal(12, 2)
  currency          String        @default("ARS")
  provider          String        @default("mercadopago")
  externalReference String        @unique @map("external_reference")
  mpPreferenceId    String?       @map("mp_preference_id")
  mpPaymentId       String?       @unique @map("mp_payment_id")
  payerEmail        String?       @map("payer_email")
  payerName         String?       @map("payer_name")
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")
  event             event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user              user          @relation(fields: [userId], references: [id], onDelete: Cascade)
  tickets           ticket[]
}

model event {
  id                   Int              @id @default(autoincrement())
  name                 String
  date                 DateTime
  location             String
  description          String?
  bannerUrl            String?          @map("banner_url")
  status               EventStatus      @default(draft)
  producerId           Int              @map("producer_id")
  capacityTotal        Int?             @map("capacity_total")
  isRsvpAllowed        Boolean          @default(true) @map("is_rsvp_allowed")
  eventGenre           String?          @map("event_genre")
  showRemainingTickets Boolean          @default(true) @map("show_remaining_tickets")
  createdAt            DateTime         @default(now()) @map("created_at")
  isSoldOut            Boolean          @default(false) @map("is_sold_out")
  producer             producer         @relation(fields: [producerId], references: [id], onUpdate: NoAction)
  eventArtists         eventArtist[]
  guestList            guestList[]
  participants         participant[]
  payments             payment[]
  rrppAssignments      rrppAssignment[]
  tickets              ticket[]
  ticketTypes          ticketType[]
}

model artist {
  id           Int           @id @default(autoincrement())
  name         String
  bio          String?
  imageUrl     String?       @map("image_url")
  socialLinks  Json?         @map("social_links")
  eventArtists eventArtist[]
}

model eventArtist {
  eventId     Int     @map("event_id")
  artistId    Int     @map("artist_id")
  order       Int?
  slotTime    String? @map("slot_time")
  isHeadliner Boolean @default(false) @map("is_headliner")
  artist      artist  @relation(fields: [artistId], references: [id], onDelete: Cascade)
  event       event   @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@id([eventId, artistId])
  @@map("event_artist")
}

model ticketType {
  id                  Int       @id @default(autoincrement())
  eventId             Int       @map("event_id")
  code                String
  label               String
  price               Decimal   @db.Decimal(12, 2)
  stockMax            Int       @map("stock_max")
  stockCurrent        Int       @map("stock_current")
  userMaxPerType      Int       @default(5) @map("user_max_per_type")
  minPurchaseQuantity Int       @default(1) @map("min_purchase_quantity")
  scanExpiration      DateTime? @map("scan_expiration")
  isVisible           Boolean   @default(true) @map("is_visible")
  isDisabled          Boolean   @default(false) @map("is_disabled")
  tickets             ticket[]
  event               event     @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, code])
  @@map("ticket_type")
}

model ticket {
  id                Int          @id @default(autoincrement())
  eventId           Int          @map("event_id")
  ownerId           String       @map("owner_id")
  typeId            Int          @map("type_id")
  paymentId         Int?         @map("payment_id")
  qrCode            String       @unique @map("qr_code")
  code              String?      @unique
  status            TicketStatus @default(pending)
  transferredFromId String?      @map("transferred_from_id")
  createdAt         DateTime     @default(now()) @map("created_at")
  event             event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  owner             user         @relation("ticketsToUser_ownerId", fields: [ownerId], references: [id])
  payment           payment?     @relation(fields: [paymentId], references: [id])
  transferredFrom   user?        @relation("ticketsToUser_transferredFromId", fields: [transferredFromId], references: [id])
  type              ticketType   @relation(fields: [typeId], references: [id], onDelete: Cascade)
}

model rrppAssignment {
  rrppUserId     String  @map("rrpp_user_id")
  eventId        Int     @map("event_id")
  commissionRate Decimal @default(0.10) @map("commission_rate")
  freesGranted   Int     @default(0) @map("frees_granted")
  event          event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  rrppUser       user    @relation(fields: [rrppUserId], references: [id], onDelete: Cascade)

  @@id([rrppUserId, eventId])
  @@map("rrpp_assignment")
}

model participant {
  userId  String  @map("user_id")
  eventId Int     @map("event_id")
  viaRsvp Boolean @default(false) @map("via_rsvp")
  qrCode  String? @map("qr_code")
  event   event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user    user    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, eventId])
}

model log {
  id        Int      @id @default(autoincrement())
  userId    String?  @map("user_id")
  action    String
  timestamp DateTime @default(now())
  details   Json?
  user      user?    @relation(fields: [userId], references: [id])
}

model message {
  id         Int      @id @default(autoincrement())
  senderId   String   @map("sender_id")
  receiverId String   @map("receiver_id")
  message    String
  timestamp  DateTime @default(now())
  readStatus Boolean  @default(false) @map("read_status")
  receiver   user     @relation("messagesToUser_receiverId", fields: [receiverId], references: [id], onDelete: Cascade)
  sender     user     @relation("messagesToUser_senderId", fields: [senderId], references: [id], onDelete: Cascade)
}

model guestList {
  id              Int         @id @default(autoincrement())
  eventId         Int         @map("event_id")
  fullName        String      @map("full_name")
  normalizedName  String      @map("normalized_name")
  email           String
  age             String?
  invitedBy       String?     @map("invited_by")
  gender          String?
  status          GuestStatus @default(invited)
  qrCode          String      @unique @map("qr_code")
  checkedInAt     DateTime?   @map("checked_in_at")
  checkedInBy     String?     @map("checked_in_by")
  importedAt      DateTime    @default(now()) @map("imported_at")
  importedBy      String      @map("imported_by")
  timestamp       String?
  checkedInByUser user?       @relation(fields: [checkedInBy], references: [id])
  event           event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  importedByUser  user        @relation("guestListImporter", fields: [importedBy], references: [id])

  @@unique([eventId, email, normalizedName])
  @@index([eventId, normalizedName])
  @@map("guest_list")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model producer {
  id              Int      @id @default(autoincrement())
  user_id         String   @unique
  company_name    String?
  commission_rate Decimal  @default(0.15) @db.Decimal(5, 4)
  bank_account    String?
  tax_id          String?
  address         String?
  phone           String?
  is_active       Boolean  @default(true)
  created_at      DateTime @default(now())
  updated_at      DateTime
  event           event[]
  user            user     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([is_active])
  @@index([user_id])
}

enum GuestStatus {
  invited
  checked_in
  no_show
}

enum Role {
  superadmin
  head_producer
  rrpp
  qr_scanner
  user
}

enum EventStatus {
  draft
  published
  finished
}

enum TicketStatus {
  pending
  paid
  used
  transferred
  refunded
}

enum PaymentStatus {
  pending
  approved
  rejected
  cancelled
  refunded
  in_process
}
